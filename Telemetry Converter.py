import os
import sys
import tkinter as tk
from tkinter import filedialog
import math
import datetime
import struct
import numpy as np
import pandas as pd

# --- External Dependencies Check and Import ---
try:
    import duckdb
    import cantools 
    # Assumes ldparser is installed or available locally
    from ldparser.ldparser import ldVehicle, ldVenue, ldEvent, ldHead, ldChan, ldData 
except ImportError as e:
    print(f"ERROR: One or more required libraries are not installed or accessible.")
    print(f"Missing: {e.name}")
    print("Please ensure you have duckdb, pandas, numpy, cantools, and ldparser installed/available.")
    sys.exit(1)


# ====================================================================
# SECTION 1: CORE LOGGING CLASSES (from data_log.py and motec_log.py)
# ====================================================================

class Message(object):
    """ A single message in a time series of data. """
    def __init__(self, timestamp=0, value=0):
        self.timestamp = float(timestamp)
        self.value = float(value)

    def __str__(self):
        return "t=%f, value=%f" % (self.timestamp, self.value)

class Channel(object):
    """ Represents a singe channel of data containing a time series of values."""
    def __init__(self, name, units, data_type, decimals, messages=None):
        self.name = str(name)
        self.units = str(units)
        self.data_type = data_type
        self.decimals = decimals
        if messages:
            self.messages = messages
        else:
            self.messages = []

    def start(self):
        if self.messages:
            return self.messages[0].timestamp
        else:
            return 0

    def end(self):
        if self.messages:
            return self.messages[-1].timestamp
        else:
            return 0

    def avg_frequency(self):
        """ Computes the average frequency from the samples based on the duration of the channel
        and the number of messages"""
        if len(self.messages) >= 2:
            dt = self.end() - self.start()
            return len(self.messages) / dt if dt > 0 else 0
        else:
            return 0

    def __str__(self):
        return "Channel: %s, Units: %s, Decimals: %d, Messages: %d, Frequency: %.2f Hz" % \
        (self.name, self.units, self.decimals, len(self.messages), self.avg_frequency())

class DataLog(object):
    """ Container for storing log data which contains a set of channels with time series data."""
    def __init__(self, name=""):
        self.name = name
        self.channels = {}

    def clear(self):
        self.channels = {}

    def add_channel(self, name, units, data_type, decimals, initial_message=None):
        msg = [] if not initial_message else [initial_message]
        self.channels[name] = Channel(name, units, data_type, decimals, msg)

    def start(self):
        t = math.inf
        for name, channel in self.channels.items():
            t = min(t, channel.start())
        return t if t != math.inf else 0.0

    def end(self):
        end = 0
        for name, channel in self.channels.items():
            end = max(end, channel.end())
        return end

    def duration(self):
        return self.end() - self.start()
        
    def from_csv_log(self, log_lines):
        """ 
        Adapted version of from_csv_log to process the enhanced, resampled CSV 
        generated by the DuckDB extraction logic.
        """
        self.clear()
        if not log_lines: return

        # First line is the header (time, Throttle_Pos, Brake_Pos, ...)
        header = log_lines[0].strip("\n\r")
        channel_keys = header.split(",")[1:]
        
        # Define metadata for channels in the final MoTeC format
        CHANNEL_METADATA = {
            'Throttle_Pos': {'name': 'Throttle Pos', 'units': '%', 'decimals': 1},
            'Brake_Pos': {'name': 'Brake Pos', 'units': '%', 'decimals': 1},
            'Speed_KPH': {'name': 'Vehicle Speed', 'units': 'km/h', 'decimals': 2},
            'Boost_Pressure': {'name': 'Boost Press', 'units': 'kPa', 'decimals': 0},
            'Coolant_Temp': {'name': 'Water Temp', 'units': 'degC', 'decimals': 1},
            'Engine_RPM': {'name': 'Engine RPM', 'units': 'rpm', 'decimals': 0},
            'Gear_Position': {'name': 'Gear', 'units': '', 'decimals': 0}, # Added Gear
            # Add other channels here if needed
        }
        
        # Initialize channels
        channel_dict = {} # Key: MoTeC Channel Name, Value: Column Index in CSV
        for i, key_name in enumerate(channel_keys):
            meta = CHANNEL_METADATA.get(key_name, {'name': key_name, 'units': '', 'decimals': 2})
            self.add_channel(meta['name'], meta['units'], float, meta['decimals'])
            channel_dict[meta['name']] = i + 1 # +1 because the first column (0) is time

        # Populate channels with data
        invalid_channels = []
        for line in log_lines[1:]:
            line = line.strip("\n\r")
            if not line: continue
            values = line.split(",")

            try:
                t = float(values[0])
            except ValueError:
                print(f"WARNING: Skipping line due to invalid